From 7f6337b4fb2286cbf696fb215c07f8cc646f7069 Mon Sep 17 00:00:00 2001
From: Maxqia <public@maxqia.com>
Date: Sun, 25 Dec 2016 19:43:54 -0800
Subject: [PATCH] Add ability to add materials to Material (thx Cauldron)


diff --git a/src/main/java/org/bukkit/Material.java b/src/main/java/org/bukkit/Material.java
index fcc76e19..a60776dc 100644
--- a/src/main/java/org/bukkit/Material.java
+++ b/src/main/java/org/bukkit/Material.java
@@ -4,6 +4,14 @@ import java.lang.reflect.Constructor;
 import java.util.Arrays;
 import java.util.Map;
 
+// PoreRT start
+import java.lang.reflect.Array;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.List;
+// PoreRT end
+
 import org.apache.commons.lang.Validate;
 import org.bukkit.map.MapView;
 import org.bukkit.material.Bed;
@@ -540,15 +548,31 @@ public enum Material {
 
     private final int id;
     private final Constructor<? extends MaterialData> ctor;
-    private static Material[] byId = new Material[383];
-    private final static Map<String, Material> BY_NAME = Maps.newHashMap();
+    private static Material[] byId = new Material[32000]; // PoreRT & Cauldron bump material ID array size
+    private static Map<String, Material> BY_NAME = Maps.newHashMap(); // Cauldron - remove final
     private final int maxStack;
     private final short durability;
+    // Cauldron start
+    private static Object reflectionFactory = null; // PoreRT move static block
+    private static Method newConstructorAccessor = null; // assignments to type definitions
+    private static Method newInstance = null;
+    private static Method newFieldAccessor = null;
+    private static Method fieldAccessorSet = null;
+    private static boolean isSetup = false;
+    private boolean isForgeBlock = false;
+    // Cauldron end
 
     private Material(final int id) {
         this(id, 64);
     }
 
+    // Cauldron start - constructor used to set if the Material is a block or not
+    private Material(final int id, boolean flag) {
+        this(id, 64);
+        this.isForgeBlock = flag;
+    }
+    // Cauldron end
+
     private Material(final int id, final int stack) {
         this(id, stack, MaterialData.class);
     }
@@ -649,7 +673,7 @@ public enum Material {
      * @return true if this material is a block
      */
     public boolean isBlock() {
-        return id < 256;
+        return id < 256 || isForgeBlock; // Cauldron
     }
 
     /**
@@ -1453,4 +1477,200 @@ public enum Material {
                 return true;
         }
     }
+
+    /* ===============================  Cauldron START ============================= */
+
+    // use a normalize() function to ensure it is accessible after a round-trip
+    public static String normalizeName(String name) {
+        return name.toUpperCase().replaceAll("(:|\\s)", "_").replaceAll("\\W", "");
+    }
+
+    public static Material addMaterial(int id, boolean isBlock)
+    {
+        return addMaterial(id, "X" + String.valueOf(id), isBlock);
+    }
+
+    public static Material addMaterial(int id, String name, boolean isBlock) {
+      if (byId[id] == null) {
+        String materialName = normalizeName(name);
+        Material material = (Material) addEnum(Material.class, materialName, new Class[]{Integer.TYPE, Boolean.TYPE}, new Object[]{Integer.valueOf(id), isBlock});
+        byId[id] = material;
+        BY_NAME.put(materialName, material);
+        BY_NAME.put("X" + String.valueOf(id), material);
+        return material;
+      }
+      return null;
+    }
+
+    public static void setMaterialName(int id, String name, boolean flag) {
+      String materialName = normalizeName(name);
+
+      if (byId[id] == null)
+      {
+        addMaterial(id, materialName, flag);
+      }
+      else // replace existing enum
+      {
+          Material material = getMaterial(id);
+          BY_NAME.remove(material);
+          Material newMaterial = replaceEnum(Material.class, materialName, material.ordinal(), new Class[] { Integer.TYPE }, new Object[] { Integer.valueOf(id) });
+          if (newMaterial == null)
+              System.out.println("Error replacing Material " + name + " with id " + id);
+          else {
+              byId[id] = newMaterial;
+              BY_NAME.put(materialName, newMaterial);
+          }
+      }
+    }
+
+    private static void setup()
+    {
+      if (isSetup)
+      {
+        return;
+      }
+      try {
+        Method getReflectionFactory = Class.forName("sun.reflect.ReflectionFactory").getDeclaredMethod("getReflectionFactory", new Class[0]);
+        reflectionFactory = getReflectionFactory.invoke(null, new Object[0]);
+        newConstructorAccessor = Class.forName("sun.reflect.ReflectionFactory").getDeclaredMethod("newConstructorAccessor", new Class[] { Constructor.class });
+        newInstance = Class.forName("sun.reflect.ConstructorAccessor").getDeclaredMethod("newInstance", new Class[] { Object[].class });
+        newFieldAccessor = Class.forName("sun.reflect.ReflectionFactory").getDeclaredMethod("newFieldAccessor", new Class[] { Field.class, Boolean.TYPE });
+        fieldAccessorSet = Class.forName("sun.reflect.FieldAccessor").getDeclaredMethod("set", new Class[] { Object.class, Object.class });
+      } catch (Exception e) {
+        e.printStackTrace();
+      }
+
+      isSetup = true;
+    }
+
+    @SuppressWarnings("rawtypes")
+    private static Object getConstructorAccessor(Class<?> enumClass, Class<?>[] additionalParameterTypes) throws Exception {
+      Class[] parameterTypes = null;
+
+      parameterTypes = new Class[additionalParameterTypes.length + 2];
+      parameterTypes[0] = String.class;
+      parameterTypes[1] = Integer.TYPE;
+      System.arraycopy(additionalParameterTypes, 0, parameterTypes, 2, additionalParameterTypes.length);
+
+      return newConstructorAccessor.invoke(reflectionFactory, new Object[] { enumClass.getDeclaredConstructor(parameterTypes) });
+    }
+
+    private static <T extends Enum<?>> T makeEnum(Class<T> enumClass, String value, int ordinal, Class<?>[] additionalTypes, Object[] additionalValues) throws Exception {
+      Object[] parms = null;
+
+      parms = new Object[additionalValues.length + 2];
+      parms[0] = value;
+      parms[1] = Integer.valueOf(ordinal);
+      System.arraycopy(additionalValues, 0, parms, 2, additionalValues.length);
+
+      return (T)enumClass.cast(newInstance.invoke(getConstructorAccessor(enumClass, additionalTypes), new Object[] { parms }));
+    }
+
+    private static void setFailsafeFieldValue(Field field, Object target, Object value) throws Exception {
+      field.setAccessible(true);
+      Field modifiersField = Field.class.getDeclaredField("modifiers");
+      modifiersField.setAccessible(true);
+      modifiersField.setInt(field, field.getModifiers() & 0xFFFFFFEF);
+      Object fieldAccessor = newFieldAccessor.invoke(reflectionFactory, new Object[] { field, Boolean.valueOf(false) });
+      fieldAccessorSet.invoke(fieldAccessor, new Object[] { target, value });
+    }
+
+    private static void blankField(Class<?> enumClass, String fieldName) throws Exception {
+      for (Field field : Class.class.getDeclaredFields())
+        if (field.getName().contains(fieldName)) {
+          field.setAccessible(true);
+          setFailsafeFieldValue(field, enumClass, null);
+          break;
+        }
+    }
+
+    private static void cleanEnumCache(Class<?> enumClass) throws Exception
+    {
+      blankField(enumClass, "enumConstantDirectory");
+      blankField(enumClass, "enumConstants");
+    }
+
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    public static <T extends Enum<?>> T replaceEnum(Class<T> enumType, String enumName, int ordinal,  Class<?>[] paramTypes, Object[] paramValues)
+    {
+      if (!isSetup) setup();
+      Field valuesField = null;
+      Field[] fields = enumType.getDeclaredFields();
+      int flags = 4122;
+      String valueType = String.format("[L%s;", new Object[] { enumType.getName() });
+
+      for (Field field : fields) {
+        if (((field.getModifiers() & flags) != flags) || (!field.getType().getName().equals(valueType))) {
+          continue;
+        }
+        valuesField = field;
+        break;
+      }
+
+      valuesField.setAccessible(true);
+      try
+      {
+        Enum[] previousValues = (Enum[])(Enum[])valuesField.get(enumType);
+        Enum[] newValues = new Enum[previousValues.length];
+        Enum newValue = null;
+        for (Enum enumValue : previousValues)
+        {
+            if (enumValue.ordinal() == ordinal)
+            {
+               newValue = makeEnum(enumType, enumName, ordinal, paramTypes, paramValues);
+               newValues[enumValue.ordinal()] =  newValue;
+            }
+            else newValues[enumValue.ordinal()] = enumValue;
+        }
+        List values = new ArrayList(Arrays.asList(newValues));
+
+        setFailsafeFieldValue(valuesField, null, values.toArray((Enum[])(Enum[])Array.newInstance(enumType, 0)));
+        cleanEnumCache(enumType);
+        return (T) newValue;
+      } catch (Exception e) {
+        e.printStackTrace();
+        throw new RuntimeException(e.getMessage(), e);
+      }
+    }
+
+    @SuppressWarnings({ "rawtypes", "unchecked" }) // PoreRT : added addEnum
+    public static <T extends Enum<?>> T addEnum(Class<T> enumType, String enumName, Class<?>[] paramTypes, Object[] paramValues)
+    {
+      if (!isSetup) setup();
+      Field valuesField = null;
+      Field[] fields = enumType.getDeclaredFields();
+      String valueType = String.format("[L%s;", new Object[] { enumType.getName() });
+
+      for (Field field : fields) {
+        if (!field.getName().equals("$VALUES") && !field.getName().equals("ENUM$VALUES"))
+            continue;
+        if (!field.getType().getName().equals(valueType))
+            continue;
+        valuesField = field;
+        break;
+      }
+
+      if(valuesField == null)
+      {
+          System.out.println("[WARNING] addEnum not working due to valuesField not being able to be found!");
+          return null;
+      }
+
+      valuesField.setAccessible(true);
+      try
+      {
+        Enum[] previousValues = (Enum[])(Enum[])valuesField.get(enumType);
+        List values = new ArrayList(Arrays.asList(previousValues));
+        Enum newValue = makeEnum(enumType, enumName, values.size(), paramTypes, paramValues);
+        values.add(newValue);
+        setFailsafeFieldValue(valuesField, null, values.toArray((Enum[])(Enum[])Array.newInstance(enumType, 0)));
+        cleanEnumCache(enumType);
+
+        return (T) newValue;
+      } catch (Exception e) {
+        e.printStackTrace();
+        throw new RuntimeException(e.getMessage(), e);
+      }
+    }
+    /* ===============================  Cauldron END============================= */
 }
-- 
2.16.2.windows.1

